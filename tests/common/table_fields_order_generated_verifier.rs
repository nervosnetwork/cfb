//! This file is auto-generated by cfbc.
use super::table_fields_order_generated as reader;


impl<'a> Verify for reader::Err<'a> {
    fn verify(&self) -> Result {
        let tab = self._tab;
        let buf = tab.buf;
        let buf_len = buf.len();

        if tab.loc > MAX_OFFSET_LOC || tab.loc + flatbuffers::SIZE_SOFFSET > buf_len {
            return Err(Error::OutOfBounds);
        }

        let vtab_loc = {
            let soffset_slice = &buf[tab.loc..];
            let soffset = flatbuffers::read_scalar::<flatbuffers::SOffsetT>(soffset_slice);
            if soffset >= 0 {
                tab.loc.checked_sub(soffset as usize)
            } else {
                soffset
                    .checked_neg()
                    .and_then(|foffset| tab.loc.checked_add(foffset as usize))
            }
        }
        .ok_or(Error::OutOfBounds)?;
        if vtab_loc
            .checked_add(flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET)
            .filter(|loc| *loc <= buf_len)
            .is_none()
        {
            return Err(Error::OutOfBounds);
        }

        let vtab = tab.vtable();
        let vtab_num_bytes = vtab.num_bytes();
        let object_inline_num_bytes = vtab.object_inline_num_bytes();
        if vtab_num_bytes < flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET
            || object_inline_num_bytes < flatbuffers::SIZE_SOFFSET
        {
            return Err(Error::OutOfBounds);
        }
        if vtab_loc
            .checked_add(vtab_num_bytes)
            .filter(|loc| *loc <= buf_len)
            .is_none()
        {
            return Err(Error::OutOfBounds);
        }
        if tab
            .loc
            .checked_add(object_inline_num_bytes)
            .filter(|loc| *loc <= buf_len)
            .is_none()
        {
            return Err(Error::OutOfBounds);
        }

        for i in 0..vtab.num_fields() {
            let voffset = vtab.get_field(i) as usize;
            if (voffset > 0 && voffset < flatbuffers::SIZE_SOFFSET)
                || voffset >= object_inline_num_bytes
            {
                return Err(Error::OutOfBounds);
            }
        }

        if Self::VT_REASON as usize + flatbuffers::SIZE_VOFFSET
            <= vtab_num_bytes
        {
            let voffset = vtab.get(Self::VT_REASON) as usize;
            if voffset > 0 {
                if voffset + 4 > object_inline_num_bytes {
                    return Err(Error::OutOfBounds);
                }

                StringVerifier::follow(buf, try_follow_uoffset(buf, tab.loc + voffset)?).verify()?;
            }
        }

        Ok(())
    }
}

impl<'a> Verify for reader::Ok<'a> {
    fn verify(&self) -> Result {
        let tab = self._tab;
        let buf = tab.buf;
        let buf_len = buf.len();

        if tab.loc > MAX_OFFSET_LOC || tab.loc + flatbuffers::SIZE_SOFFSET > buf_len {
            return Err(Error::OutOfBounds);
        }

        let vtab_loc = {
            let soffset_slice = &buf[tab.loc..];
            let soffset = flatbuffers::read_scalar::<flatbuffers::SOffsetT>(soffset_slice);
            if soffset >= 0 {
                tab.loc.checked_sub(soffset as usize)
            } else {
                soffset
                    .checked_neg()
                    .and_then(|foffset| tab.loc.checked_add(foffset as usize))
            }
        }
        .ok_or(Error::OutOfBounds)?;
        if vtab_loc
            .checked_add(flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET)
            .filter(|loc| *loc <= buf_len)
            .is_none()
        {
            return Err(Error::OutOfBounds);
        }

        let vtab = tab.vtable();
        let vtab_num_bytes = vtab.num_bytes();
        let object_inline_num_bytes = vtab.object_inline_num_bytes();
        if vtab_num_bytes < flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET
            || object_inline_num_bytes < flatbuffers::SIZE_SOFFSET
        {
            return Err(Error::OutOfBounds);
        }
        if vtab_loc
            .checked_add(vtab_num_bytes)
            .filter(|loc| *loc <= buf_len)
            .is_none()
        {
            return Err(Error::OutOfBounds);
        }
        if tab
            .loc
            .checked_add(object_inline_num_bytes)
            .filter(|loc| *loc <= buf_len)
            .is_none()
        {
            return Err(Error::OutOfBounds);
        }

        for i in 0..vtab.num_fields() {
            let voffset = vtab.get_field(i) as usize;
            if (voffset > 0 && voffset < flatbuffers::SIZE_SOFFSET)
                || voffset >= object_inline_num_bytes
            {
                return Err(Error::OutOfBounds);
            }
        }

        if Self::VT_VALUE as usize + flatbuffers::SIZE_VOFFSET
            <= vtab_num_bytes
        {
            let voffset = vtab.get(Self::VT_VALUE) as usize;
            if voffset > 0 && object_inline_num_bytes - voffset < 4 {
                return Err(Error::OutOfBounds);
            }
        }

        Ok(())
    }
}

impl<'a> Verify for reader::T<'a> {
    fn verify(&self) -> Result {
        let tab = self._tab;
        let buf = tab.buf;
        let buf_len = buf.len();

        if tab.loc > MAX_OFFSET_LOC || tab.loc + flatbuffers::SIZE_SOFFSET > buf_len {
            return Err(Error::OutOfBounds);
        }

        let vtab_loc = {
            let soffset_slice = &buf[tab.loc..];
            let soffset = flatbuffers::read_scalar::<flatbuffers::SOffsetT>(soffset_slice);
            if soffset >= 0 {
                tab.loc.checked_sub(soffset as usize)
            } else {
                soffset
                    .checked_neg()
                    .and_then(|foffset| tab.loc.checked_add(foffset as usize))
            }
        }
        .ok_or(Error::OutOfBounds)?;
        if vtab_loc
            .checked_add(flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET)
            .filter(|loc| *loc <= buf_len)
            .is_none()
        {
            return Err(Error::OutOfBounds);
        }

        let vtab = tab.vtable();
        let vtab_num_bytes = vtab.num_bytes();
        let object_inline_num_bytes = vtab.object_inline_num_bytes();
        if vtab_num_bytes < flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET
            || object_inline_num_bytes < flatbuffers::SIZE_SOFFSET
        {
            return Err(Error::OutOfBounds);
        }
        if vtab_loc
            .checked_add(vtab_num_bytes)
            .filter(|loc| *loc <= buf_len)
            .is_none()
        {
            return Err(Error::OutOfBounds);
        }
        if tab
            .loc
            .checked_add(object_inline_num_bytes)
            .filter(|loc| *loc <= buf_len)
            .is_none()
        {
            return Err(Error::OutOfBounds);
        }

        for i in 0..vtab.num_fields() {
            let voffset = vtab.get_field(i) as usize;
            if (voffset > 0 && voffset < flatbuffers::SIZE_SOFFSET)
                || voffset >= object_inline_num_bytes
            {
                return Err(Error::OutOfBounds);
            }
        }

        if Self::VT_A_UBYTE as usize + flatbuffers::SIZE_VOFFSET
            <= vtab_num_bytes
        {
            let voffset = vtab.get(Self::VT_A_UBYTE) as usize;
            if voffset > 0 && object_inline_num_bytes - voffset < 1 {
                return Err(Error::OutOfBounds);
            }
        }

        if Self::VT_COMPLEX as usize + flatbuffers::SIZE_VOFFSET
            <= vtab_num_bytes
        {
            let voffset = vtab.get(Self::VT_COMPLEX) as usize;
            if voffset > 0 && object_inline_num_bytes - voffset < 16 {
                return Err(Error::OutOfBounds);
            }
        }

        if Self::VT_A_UINT32 as usize + flatbuffers::SIZE_VOFFSET
            <= vtab_num_bytes
        {
            let voffset = vtab.get(Self::VT_A_UINT32) as usize;
            if voffset > 0 && object_inline_num_bytes - voffset < 4 {
                return Err(Error::OutOfBounds);
            }
        }

        if Self::VT_RESULT_TYPE as usize + flatbuffers::SIZE_VOFFSET
            <= vtab_num_bytes
        {
            let voffset = vtab.get(Self::VT_RESULT_TYPE) as usize;
            if voffset > 0 && object_inline_num_bytes - voffset < 1 {
                return Err(Error::OutOfBounds);
            }
        }

        if Self::VT_RESULT as usize + flatbuffers::SIZE_VOFFSET
            <= vtab_num_bytes
        {
            let voffset = vtab.get(Self::VT_RESULT) as usize;
            if voffset > 0 {
                if voffset + 4 > object_inline_num_bytes {
                    return Err(Error::OutOfBounds);
                }

                match self.result_type() {
                    reader::Result::Ok => self
                        .result_as_ok()
                        .ok_or(Error::UnmatchedUnion)?
                        .verify()?,
                    reader::Result::Err => self
                        .result_as_err()
                        .ok_or(Error::UnmatchedUnion)?
                        .verify()?,
                    reader::Result::NONE => return Err(Error::UnmatchedUnion),
                }
            }
        }

        if Self::VT_A_UINT64 as usize + flatbuffers::SIZE_VOFFSET
            <= vtab_num_bytes
        {
            let voffset = vtab.get(Self::VT_A_UINT64) as usize;
            if voffset > 0 && object_inline_num_bytes - voffset < 8 {
                return Err(Error::OutOfBounds);
            }
        }

        if Self::VT_UINT16_ARRAY as usize + flatbuffers::SIZE_VOFFSET
            <= vtab_num_bytes
        {
            let voffset = vtab.get(Self::VT_UINT16_ARRAY) as usize;
            if voffset > 0 {
                if voffset + 4 > object_inline_num_bytes {
                    return Err(Error::OutOfBounds);
                }

                let uint16_array_verifier = VectorVerifier::follow(
                    buf,
                    try_follow_uoffset(buf, tab.loc + voffset)?,
                );
                uint16_array_verifier.verify_scalar_elements(2)?;
            }
        }

        if Self::VT_COLOR as usize + flatbuffers::SIZE_VOFFSET
            <= vtab_num_bytes
        {
            let voffset = vtab.get(Self::VT_COLOR) as usize;
            if voffset > 0 && object_inline_num_bytes - voffset < 1 {
                return Err(Error::OutOfBounds);
            }
        }

        Ok(())
    }
}