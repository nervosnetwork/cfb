// automatically generated by the FlatBuffers compiler, do not modify



use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[allow(unused_imports, dead_code)]
pub mod reflection {

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;

#[allow(non_camel_case_types)]
#[repr(i8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum BaseType {
  None = 0,
  UType = 1,
  Bool = 2,
  Byte = 3,
  UByte = 4,
  Short = 5,
  UShort = 6,
  Int = 7,
  UInt = 8,
  Long = 9,
  ULong = 10,
  Float = 11,
  Double = 12,
  String = 13,
  Vector = 14,
  Obj = 15,
  Union = 16,

}

const ENUM_MIN_BASE_TYPE: i8 = 0;
const ENUM_MAX_BASE_TYPE: i8 = 16;

impl<'a> flatbuffers::Follow<'a> for BaseType {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for BaseType {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = i8::to_le(self as i8);
    let p = &n as *const i8 as *const BaseType;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = i8::from_le(self as i8);
    let p = &n as *const i8 as *const BaseType;
    unsafe { *p }
  }
}

impl flatbuffers::Push for BaseType {
    type Output = BaseType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<BaseType>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_BASE_TYPE:[BaseType; 17] = [
  BaseType::None,
  BaseType::UType,
  BaseType::Bool,
  BaseType::Byte,
  BaseType::UByte,
  BaseType::Short,
  BaseType::UShort,
  BaseType::Int,
  BaseType::UInt,
  BaseType::Long,
  BaseType::ULong,
  BaseType::Float,
  BaseType::Double,
  BaseType::String,
  BaseType::Vector,
  BaseType::Obj,
  BaseType::Union
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_BASE_TYPE:[&'static str; 17] = [
    "None",
    "UType",
    "Bool",
    "Byte",
    "UByte",
    "Short",
    "UShort",
    "Int",
    "UInt",
    "Long",
    "ULong",
    "Float",
    "Double",
    "String",
    "Vector",
    "Obj",
    "Union"
];

pub fn enum_name_base_type(e: BaseType) -> &'static str {
  let index = e as i8;
  ENUM_NAMES_BASE_TYPE[index as usize]
}

pub enum TypeOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Type<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Type<'a> {
    type Inner = Type<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Type<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Type {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TypeArgs) -> flatbuffers::WIPOffset<Type<'bldr>> {
      let mut builder = TypeBuilder::new(_fbb);
      builder.add_index(args.index);
      builder.add_element(args.element);
      builder.add_base_type(args.base_type);
      builder.finish()
    }

    pub const VT_BASE_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_ELEMENT: flatbuffers::VOffsetT = 6;
    pub const VT_INDEX: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn base_type(&self) -> BaseType {
    self._tab.get::<BaseType>(Type::VT_BASE_TYPE, Some(BaseType::None)).unwrap()
  }
  #[inline]
  pub fn element(&self) -> BaseType {
    self._tab.get::<BaseType>(Type::VT_ELEMENT, Some(BaseType::None)).unwrap()
  }
  #[inline]
  pub fn index(&self) -> i32 {
    self._tab.get::<i32>(Type::VT_INDEX, Some(-1)).unwrap()
  }
}

pub struct TypeArgs {
    pub base_type: BaseType,
    pub element: BaseType,
    pub index: i32,
}
impl<'a> Default for TypeArgs {
    #[inline]
    fn default() -> Self {
        TypeArgs {
            base_type: BaseType::None,
            element: BaseType::None,
            index: -1,
        }
    }
}
pub struct TypeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TypeBuilder<'a, 'b> {
  #[inline]
  pub fn add_base_type(&mut self, base_type: BaseType) {
    self.fbb_.push_slot::<BaseType>(Type::VT_BASE_TYPE, base_type, BaseType::None);
  }
  #[inline]
  pub fn add_element(&mut self, element: BaseType) {
    self.fbb_.push_slot::<BaseType>(Type::VT_ELEMENT, element, BaseType::None);
  }
  #[inline]
  pub fn add_index(&mut self, index: i32) {
    self.fbb_.push_slot::<i32>(Type::VT_INDEX, index, -1);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TypeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TypeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Type<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum KeyValueOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct KeyValue<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for KeyValue<'a> {
    type Inner = KeyValue<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> KeyValue<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        KeyValue {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args KeyValueArgs<'args>) -> flatbuffers::WIPOffset<KeyValue<'bldr>> {
      let mut builder = KeyValueBuilder::new(_fbb);
      if let Some(x) = args.value { builder.add_value(x); }
      if let Some(x) = args.key { builder.add_key(x); }
      builder.finish()
    }

    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn key(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KeyValue::VT_KEY, None).unwrap()
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &KeyValue) ->  bool {
    self.key() < o.key()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) ->  ::std::cmp::Ordering {
    let key = self.key();
    key.cmp(&val)
  }
  #[inline]
  pub fn value(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KeyValue::VT_VALUE, None)
  }
}

pub struct KeyValueArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub value: Option<flatbuffers::WIPOffset<&'a  str>>,
}
impl<'a> Default for KeyValueArgs<'a> {
    #[inline]
    fn default() -> Self {
        KeyValueArgs {
            key: None, // required field
            value: None,
        }
    }
}
pub struct KeyValueBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> KeyValueBuilder<'a, 'b> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KeyValue::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KeyValue::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> KeyValueBuilder<'a, 'b> {
    let start = _fbb.start_table();
    KeyValueBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<KeyValue<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, KeyValue::VT_KEY,"key");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum EnumValOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct EnumVal<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EnumVal<'a> {
    type Inner = EnumVal<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> EnumVal<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        EnumVal {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args EnumValArgs<'args>) -> flatbuffers::WIPOffset<EnumVal<'bldr>> {
      let mut builder = EnumValBuilder::new(_fbb);
      builder.add_value(args.value);
      if let Some(x) = args.documentation { builder.add_documentation(x); }
      if let Some(x) = args.union_type { builder.add_union_type(x); }
      if let Some(x) = args.object { builder.add_object(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;
    pub const VT_OBJECT: flatbuffers::VOffsetT = 8;
    pub const VT_UNION_TYPE: flatbuffers::VOffsetT = 10;
    pub const VT_DOCUMENTATION: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn name(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EnumVal::VT_NAME, None).unwrap()
  }
  #[inline]
  pub fn value(&self) -> i64 {
    self._tab.get::<i64>(EnumVal::VT_VALUE, Some(0)).unwrap()
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &EnumVal) ->  bool {
    self.value() < o.value()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: i64) ->  ::std::cmp::Ordering {
    let key = self.value();
    key.cmp(&val)
  }
  #[inline]
  pub fn object(&self) -> Option<Object<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Object<'a>>>(EnumVal::VT_OBJECT, None)
  }
  #[inline]
  pub fn union_type(&self) -> Option<Type<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Type<'a>>>(EnumVal::VT_UNION_TYPE, None)
  }
  #[inline]
  pub fn documentation(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>>>(EnumVal::VT_DOCUMENTATION, None)
  }
}

pub struct EnumValArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub value: i64,
    pub object: Option<flatbuffers::WIPOffset<Object<'a >>>,
    pub union_type: Option<flatbuffers::WIPOffset<Type<'a >>>,
    pub documentation: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<&'a  str>>>>,
}
impl<'a> Default for EnumValArgs<'a> {
    #[inline]
    fn default() -> Self {
        EnumValArgs {
            name: None, // required field
            value: 0,
            object: None,
            union_type: None,
            documentation: None,
        }
    }
}
pub struct EnumValBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EnumValBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EnumVal::VT_NAME, name);
  }
  #[inline]
  pub fn add_value(&mut self, value: i64) {
    self.fbb_.push_slot::<i64>(EnumVal::VT_VALUE, value, 0);
  }
  #[inline]
  pub fn add_object(&mut self, object: flatbuffers::WIPOffset<Object<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Object>>(EnumVal::VT_OBJECT, object);
  }
  #[inline]
  pub fn add_union_type(&mut self, union_type: flatbuffers::WIPOffset<Type<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Type>>(EnumVal::VT_UNION_TYPE, union_type);
  }
  #[inline]
  pub fn add_documentation(&mut self, documentation: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EnumVal::VT_DOCUMENTATION, documentation);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EnumValBuilder<'a, 'b> {
    let start = _fbb.start_table();
    EnumValBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EnumVal<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, EnumVal::VT_NAME,"name");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum EnumOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Enum<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Enum<'a> {
    type Inner = Enum<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Enum<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Enum {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args EnumArgs<'args>) -> flatbuffers::WIPOffset<Enum<'bldr>> {
      let mut builder = EnumBuilder::new(_fbb);
      if let Some(x) = args.documentation { builder.add_documentation(x); }
      if let Some(x) = args.attributes { builder.add_attributes(x); }
      if let Some(x) = args.underlying_type { builder.add_underlying_type(x); }
      if let Some(x) = args.values { builder.add_values(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.add_is_union(args.is_union);
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_VALUES: flatbuffers::VOffsetT = 6;
    pub const VT_IS_UNION: flatbuffers::VOffsetT = 8;
    pub const VT_UNDERLYING_TYPE: flatbuffers::VOffsetT = 10;
    pub const VT_ATTRIBUTES: flatbuffers::VOffsetT = 12;
    pub const VT_DOCUMENTATION: flatbuffers::VOffsetT = 14;

  #[inline]
  pub fn name(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Enum::VT_NAME, None).unwrap()
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &Enum) ->  bool {
    self.name() < o.name()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) ->  ::std::cmp::Ordering {
    let key = self.name();
    key.cmp(&val)
  }
  #[inline]
  pub fn values(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EnumVal<'a>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<EnumVal<'a>>>>>(Enum::VT_VALUES, None).unwrap()
  }
  #[inline]
  pub fn is_union(&self) -> bool {
    self._tab.get::<bool>(Enum::VT_IS_UNION, Some(false)).unwrap()
  }
  #[inline]
  pub fn underlying_type(&self) -> Type<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Type<'a>>>(Enum::VT_UNDERLYING_TYPE, None).unwrap()
  }
  #[inline]
  pub fn attributes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<KeyValue<'a>>>>>(Enum::VT_ATTRIBUTES, None)
  }
  #[inline]
  pub fn documentation(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>>>(Enum::VT_DOCUMENTATION, None)
  }
}

pub struct EnumArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<EnumVal<'a >>>>>,
    pub is_union: bool,
    pub underlying_type: Option<flatbuffers::WIPOffset<Type<'a >>>,
    pub attributes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<KeyValue<'a >>>>>,
    pub documentation: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<&'a  str>>>>,
}
impl<'a> Default for EnumArgs<'a> {
    #[inline]
    fn default() -> Self {
        EnumArgs {
            name: None, // required field
            values: None, // required field
            is_union: false,
            underlying_type: None, // required field
            attributes: None,
            documentation: None,
        }
    }
}
pub struct EnumBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EnumBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Enum::VT_NAME, name);
  }
  #[inline]
  pub fn add_values(&mut self, values: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<EnumVal<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Enum::VT_VALUES, values);
  }
  #[inline]
  pub fn add_is_union(&mut self, is_union: bool) {
    self.fbb_.push_slot::<bool>(Enum::VT_IS_UNION, is_union, false);
  }
  #[inline]
  pub fn add_underlying_type(&mut self, underlying_type: flatbuffers::WIPOffset<Type<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Type>>(Enum::VT_UNDERLYING_TYPE, underlying_type);
  }
  #[inline]
  pub fn add_attributes(&mut self, attributes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KeyValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Enum::VT_ATTRIBUTES, attributes);
  }
  #[inline]
  pub fn add_documentation(&mut self, documentation: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Enum::VT_DOCUMENTATION, documentation);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EnumBuilder<'a, 'b> {
    let start = _fbb.start_table();
    EnumBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Enum<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Enum::VT_NAME,"name");
    self.fbb_.required(o, Enum::VT_VALUES,"values");
    self.fbb_.required(o, Enum::VT_UNDERLYING_TYPE,"underlying_type");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FieldOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Field<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Field<'a> {
    type Inner = Field<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Field<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Field {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FieldArgs<'args>) -> flatbuffers::WIPOffset<Field<'bldr>> {
      let mut builder = FieldBuilder::new(_fbb);
      builder.add_default_real(args.default_real);
      builder.add_default_integer(args.default_integer);
      if let Some(x) = args.documentation { builder.add_documentation(x); }
      if let Some(x) = args.attributes { builder.add_attributes(x); }
      if let Some(x) = args.type_ { builder.add_type_(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.add_offset(args.offset);
      builder.add_id(args.id);
      builder.add_key(args.key);
      builder.add_required(args.required);
      builder.add_deprecated(args.deprecated);
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
    pub const VT_ID: flatbuffers::VOffsetT = 8;
    pub const VT_OFFSET: flatbuffers::VOffsetT = 10;
    pub const VT_DEFAULT_INTEGER: flatbuffers::VOffsetT = 12;
    pub const VT_DEFAULT_REAL: flatbuffers::VOffsetT = 14;
    pub const VT_DEPRECATED: flatbuffers::VOffsetT = 16;
    pub const VT_REQUIRED: flatbuffers::VOffsetT = 18;
    pub const VT_KEY: flatbuffers::VOffsetT = 20;
    pub const VT_ATTRIBUTES: flatbuffers::VOffsetT = 22;
    pub const VT_DOCUMENTATION: flatbuffers::VOffsetT = 24;

  #[inline]
  pub fn name(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Field::VT_NAME, None).unwrap()
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &Field) ->  bool {
    self.name() < o.name()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) ->  ::std::cmp::Ordering {
    let key = self.name();
    key.cmp(&val)
  }
  #[inline]
  pub fn type_(&self) -> Type<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Type<'a>>>(Field::VT_TYPE_, None).unwrap()
  }
  #[inline]
  pub fn id(&self) -> u16 {
    self._tab.get::<u16>(Field::VT_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn offset(&self) -> u16 {
    self._tab.get::<u16>(Field::VT_OFFSET, Some(0)).unwrap()
  }
  #[inline]
  pub fn default_integer(&self) -> i64 {
    self._tab.get::<i64>(Field::VT_DEFAULT_INTEGER, Some(0)).unwrap()
  }
  #[inline]
  pub fn default_real(&self) -> f64 {
    self._tab.get::<f64>(Field::VT_DEFAULT_REAL, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn deprecated(&self) -> bool {
    self._tab.get::<bool>(Field::VT_DEPRECATED, Some(false)).unwrap()
  }
  #[inline]
  pub fn required(&self) -> bool {
    self._tab.get::<bool>(Field::VT_REQUIRED, Some(false)).unwrap()
  }
  #[inline]
  pub fn key(&self) -> bool {
    self._tab.get::<bool>(Field::VT_KEY, Some(false)).unwrap()
  }
  #[inline]
  pub fn attributes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<KeyValue<'a>>>>>(Field::VT_ATTRIBUTES, None)
  }
  #[inline]
  pub fn documentation(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>>>(Field::VT_DOCUMENTATION, None)
  }
}

pub struct FieldArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub type_: Option<flatbuffers::WIPOffset<Type<'a >>>,
    pub id: u16,
    pub offset: u16,
    pub default_integer: i64,
    pub default_real: f64,
    pub deprecated: bool,
    pub required: bool,
    pub key: bool,
    pub attributes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<KeyValue<'a >>>>>,
    pub documentation: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<&'a  str>>>>,
}
impl<'a> Default for FieldArgs<'a> {
    #[inline]
    fn default() -> Self {
        FieldArgs {
            name: None, // required field
            type_: None, // required field
            id: 0,
            offset: 0,
            default_integer: 0,
            default_real: 0.0,
            deprecated: false,
            required: false,
            key: false,
            attributes: None,
            documentation: None,
        }
    }
}
pub struct FieldBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FieldBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Field::VT_NAME, name);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<Type<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Type>>(Field::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_id(&mut self, id: u16) {
    self.fbb_.push_slot::<u16>(Field::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_offset(&mut self, offset: u16) {
    self.fbb_.push_slot::<u16>(Field::VT_OFFSET, offset, 0);
  }
  #[inline]
  pub fn add_default_integer(&mut self, default_integer: i64) {
    self.fbb_.push_slot::<i64>(Field::VT_DEFAULT_INTEGER, default_integer, 0);
  }
  #[inline]
  pub fn add_default_real(&mut self, default_real: f64) {
    self.fbb_.push_slot::<f64>(Field::VT_DEFAULT_REAL, default_real, 0.0);
  }
  #[inline]
  pub fn add_deprecated(&mut self, deprecated: bool) {
    self.fbb_.push_slot::<bool>(Field::VT_DEPRECATED, deprecated, false);
  }
  #[inline]
  pub fn add_required(&mut self, required: bool) {
    self.fbb_.push_slot::<bool>(Field::VT_REQUIRED, required, false);
  }
  #[inline]
  pub fn add_key(&mut self, key: bool) {
    self.fbb_.push_slot::<bool>(Field::VT_KEY, key, false);
  }
  #[inline]
  pub fn add_attributes(&mut self, attributes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KeyValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Field::VT_ATTRIBUTES, attributes);
  }
  #[inline]
  pub fn add_documentation(&mut self, documentation: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Field::VT_DOCUMENTATION, documentation);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FieldBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FieldBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Field<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Field::VT_NAME,"name");
    self.fbb_.required(o, Field::VT_TYPE_,"type_");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ObjectOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Object<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Object<'a> {
    type Inner = Object<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Object<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Object {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ObjectArgs<'args>) -> flatbuffers::WIPOffset<Object<'bldr>> {
      let mut builder = ObjectBuilder::new(_fbb);
      if let Some(x) = args.documentation { builder.add_documentation(x); }
      if let Some(x) = args.attributes { builder.add_attributes(x); }
      builder.add_bytesize(args.bytesize);
      builder.add_minalign(args.minalign);
      if let Some(x) = args.fields { builder.add_fields(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.add_is_struct(args.is_struct);
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_FIELDS: flatbuffers::VOffsetT = 6;
    pub const VT_IS_STRUCT: flatbuffers::VOffsetT = 8;
    pub const VT_MINALIGN: flatbuffers::VOffsetT = 10;
    pub const VT_BYTESIZE: flatbuffers::VOffsetT = 12;
    pub const VT_ATTRIBUTES: flatbuffers::VOffsetT = 14;
    pub const VT_DOCUMENTATION: flatbuffers::VOffsetT = 16;

  #[inline]
  pub fn name(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Object::VT_NAME, None).unwrap()
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &Object) ->  bool {
    self.name() < o.name()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) ->  ::std::cmp::Ordering {
    let key = self.name();
    key.cmp(&val)
  }
  #[inline]
  pub fn fields(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Field<'a>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Field<'a>>>>>(Object::VT_FIELDS, None).unwrap()
  }
  #[inline]
  pub fn is_struct(&self) -> bool {
    self._tab.get::<bool>(Object::VT_IS_STRUCT, Some(false)).unwrap()
  }
  #[inline]
  pub fn minalign(&self) -> i32 {
    self._tab.get::<i32>(Object::VT_MINALIGN, Some(0)).unwrap()
  }
  #[inline]
  pub fn bytesize(&self) -> i32 {
    self._tab.get::<i32>(Object::VT_BYTESIZE, Some(0)).unwrap()
  }
  #[inline]
  pub fn attributes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<KeyValue<'a>>>>>(Object::VT_ATTRIBUTES, None)
  }
  #[inline]
  pub fn documentation(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>>>(Object::VT_DOCUMENTATION, None)
  }
}

pub struct ObjectArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub fields: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Field<'a >>>>>,
    pub is_struct: bool,
    pub minalign: i32,
    pub bytesize: i32,
    pub attributes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<KeyValue<'a >>>>>,
    pub documentation: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<&'a  str>>>>,
}
impl<'a> Default for ObjectArgs<'a> {
    #[inline]
    fn default() -> Self {
        ObjectArgs {
            name: None, // required field
            fields: None, // required field
            is_struct: false,
            minalign: 0,
            bytesize: 0,
            attributes: None,
            documentation: None,
        }
    }
}
pub struct ObjectBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ObjectBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Object::VT_NAME, name);
  }
  #[inline]
  pub fn add_fields(&mut self, fields: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Field<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Object::VT_FIELDS, fields);
  }
  #[inline]
  pub fn add_is_struct(&mut self, is_struct: bool) {
    self.fbb_.push_slot::<bool>(Object::VT_IS_STRUCT, is_struct, false);
  }
  #[inline]
  pub fn add_minalign(&mut self, minalign: i32) {
    self.fbb_.push_slot::<i32>(Object::VT_MINALIGN, minalign, 0);
  }
  #[inline]
  pub fn add_bytesize(&mut self, bytesize: i32) {
    self.fbb_.push_slot::<i32>(Object::VT_BYTESIZE, bytesize, 0);
  }
  #[inline]
  pub fn add_attributes(&mut self, attributes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KeyValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Object::VT_ATTRIBUTES, attributes);
  }
  #[inline]
  pub fn add_documentation(&mut self, documentation: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Object::VT_DOCUMENTATION, documentation);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ObjectBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ObjectBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Object<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Object::VT_NAME,"name");
    self.fbb_.required(o, Object::VT_FIELDS,"fields");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum RPCCallOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct RPCCall<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RPCCall<'a> {
    type Inner = RPCCall<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> RPCCall<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RPCCall {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RPCCallArgs<'args>) -> flatbuffers::WIPOffset<RPCCall<'bldr>> {
      let mut builder = RPCCallBuilder::new(_fbb);
      if let Some(x) = args.documentation { builder.add_documentation(x); }
      if let Some(x) = args.attributes { builder.add_attributes(x); }
      if let Some(x) = args.response { builder.add_response(x); }
      if let Some(x) = args.request { builder.add_request(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_REQUEST: flatbuffers::VOffsetT = 6;
    pub const VT_RESPONSE: flatbuffers::VOffsetT = 8;
    pub const VT_ATTRIBUTES: flatbuffers::VOffsetT = 10;
    pub const VT_DOCUMENTATION: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn name(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RPCCall::VT_NAME, None).unwrap()
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &RPCCall) ->  bool {
    self.name() < o.name()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) ->  ::std::cmp::Ordering {
    let key = self.name();
    key.cmp(&val)
  }
  #[inline]
  pub fn request(&self) -> Object<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Object<'a>>>(RPCCall::VT_REQUEST, None).unwrap()
  }
  #[inline]
  pub fn response(&self) -> Object<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Object<'a>>>(RPCCall::VT_RESPONSE, None).unwrap()
  }
  #[inline]
  pub fn attributes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<KeyValue<'a>>>>>(RPCCall::VT_ATTRIBUTES, None)
  }
  #[inline]
  pub fn documentation(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>>>(RPCCall::VT_DOCUMENTATION, None)
  }
}

pub struct RPCCallArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub request: Option<flatbuffers::WIPOffset<Object<'a >>>,
    pub response: Option<flatbuffers::WIPOffset<Object<'a >>>,
    pub attributes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<KeyValue<'a >>>>>,
    pub documentation: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<&'a  str>>>>,
}
impl<'a> Default for RPCCallArgs<'a> {
    #[inline]
    fn default() -> Self {
        RPCCallArgs {
            name: None, // required field
            request: None, // required field
            response: None, // required field
            attributes: None,
            documentation: None,
        }
    }
}
pub struct RPCCallBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RPCCallBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RPCCall::VT_NAME, name);
  }
  #[inline]
  pub fn add_request(&mut self, request: flatbuffers::WIPOffset<Object<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Object>>(RPCCall::VT_REQUEST, request);
  }
  #[inline]
  pub fn add_response(&mut self, response: flatbuffers::WIPOffset<Object<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Object>>(RPCCall::VT_RESPONSE, response);
  }
  #[inline]
  pub fn add_attributes(&mut self, attributes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KeyValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RPCCall::VT_ATTRIBUTES, attributes);
  }
  #[inline]
  pub fn add_documentation(&mut self, documentation: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RPCCall::VT_DOCUMENTATION, documentation);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RPCCallBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RPCCallBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RPCCall<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, RPCCall::VT_NAME,"name");
    self.fbb_.required(o, RPCCall::VT_REQUEST,"request");
    self.fbb_.required(o, RPCCall::VT_RESPONSE,"response");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ServiceOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Service<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Service<'a> {
    type Inner = Service<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Service<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Service {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ServiceArgs<'args>) -> flatbuffers::WIPOffset<Service<'bldr>> {
      let mut builder = ServiceBuilder::new(_fbb);
      if let Some(x) = args.documentation { builder.add_documentation(x); }
      if let Some(x) = args.attributes { builder.add_attributes(x); }
      if let Some(x) = args.calls { builder.add_calls(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_CALLS: flatbuffers::VOffsetT = 6;
    pub const VT_ATTRIBUTES: flatbuffers::VOffsetT = 8;
    pub const VT_DOCUMENTATION: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn name(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Service::VT_NAME, None).unwrap()
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &Service) ->  bool {
    self.name() < o.name()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) ->  ::std::cmp::Ordering {
    let key = self.name();
    key.cmp(&val)
  }
  #[inline]
  pub fn calls(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RPCCall<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<RPCCall<'a>>>>>(Service::VT_CALLS, None)
  }
  #[inline]
  pub fn attributes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<KeyValue<'a>>>>>(Service::VT_ATTRIBUTES, None)
  }
  #[inline]
  pub fn documentation(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>>>(Service::VT_DOCUMENTATION, None)
  }
}

pub struct ServiceArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub calls: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<RPCCall<'a >>>>>,
    pub attributes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<KeyValue<'a >>>>>,
    pub documentation: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<&'a  str>>>>,
}
impl<'a> Default for ServiceArgs<'a> {
    #[inline]
    fn default() -> Self {
        ServiceArgs {
            name: None, // required field
            calls: None,
            attributes: None,
            documentation: None,
        }
    }
}
pub struct ServiceBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ServiceBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Service::VT_NAME, name);
  }
  #[inline]
  pub fn add_calls(&mut self, calls: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<RPCCall<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Service::VT_CALLS, calls);
  }
  #[inline]
  pub fn add_attributes(&mut self, attributes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KeyValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Service::VT_ATTRIBUTES, attributes);
  }
  #[inline]
  pub fn add_documentation(&mut self, documentation: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Service::VT_DOCUMENTATION, documentation);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ServiceBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ServiceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Service<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Service::VT_NAME,"name");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum SchemaOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Schema<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Schema<'a> {
    type Inner = Schema<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Schema<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Schema {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SchemaArgs<'args>) -> flatbuffers::WIPOffset<Schema<'bldr>> {
      let mut builder = SchemaBuilder::new(_fbb);
      if let Some(x) = args.services { builder.add_services(x); }
      if let Some(x) = args.root_table { builder.add_root_table(x); }
      if let Some(x) = args.file_ext { builder.add_file_ext(x); }
      if let Some(x) = args.file_ident { builder.add_file_ident(x); }
      if let Some(x) = args.enums { builder.add_enums(x); }
      if let Some(x) = args.objects { builder.add_objects(x); }
      builder.finish()
    }

    pub const VT_OBJECTS: flatbuffers::VOffsetT = 4;
    pub const VT_ENUMS: flatbuffers::VOffsetT = 6;
    pub const VT_FILE_IDENT: flatbuffers::VOffsetT = 8;
    pub const VT_FILE_EXT: flatbuffers::VOffsetT = 10;
    pub const VT_ROOT_TABLE: flatbuffers::VOffsetT = 12;
    pub const VT_SERVICES: flatbuffers::VOffsetT = 14;

  #[inline]
  pub fn objects(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Object<'a>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Object<'a>>>>>(Schema::VT_OBJECTS, None).unwrap()
  }
  #[inline]
  pub fn enums(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Enum<'a>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Enum<'a>>>>>(Schema::VT_ENUMS, None).unwrap()
  }
  #[inline]
  pub fn file_ident(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Schema::VT_FILE_IDENT, None)
  }
  #[inline]
  pub fn file_ext(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Schema::VT_FILE_EXT, None)
  }
  #[inline]
  pub fn root_table(&self) -> Option<Object<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Object<'a>>>(Schema::VT_ROOT_TABLE, None)
  }
  #[inline]
  pub fn services(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Service<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Service<'a>>>>>(Schema::VT_SERVICES, None)
  }
}

pub struct SchemaArgs<'a> {
    pub objects: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Object<'a >>>>>,
    pub enums: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Enum<'a >>>>>,
    pub file_ident: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub file_ext: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub root_table: Option<flatbuffers::WIPOffset<Object<'a >>>,
    pub services: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Service<'a >>>>>,
}
impl<'a> Default for SchemaArgs<'a> {
    #[inline]
    fn default() -> Self {
        SchemaArgs {
            objects: None, // required field
            enums: None, // required field
            file_ident: None,
            file_ext: None,
            root_table: None,
            services: None,
        }
    }
}
pub struct SchemaBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SchemaBuilder<'a, 'b> {
  #[inline]
  pub fn add_objects(&mut self, objects: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Object<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Schema::VT_OBJECTS, objects);
  }
  #[inline]
  pub fn add_enums(&mut self, enums: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Enum<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Schema::VT_ENUMS, enums);
  }
  #[inline]
  pub fn add_file_ident(&mut self, file_ident: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Schema::VT_FILE_IDENT, file_ident);
  }
  #[inline]
  pub fn add_file_ext(&mut self, file_ext: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Schema::VT_FILE_EXT, file_ext);
  }
  #[inline]
  pub fn add_root_table(&mut self, root_table: flatbuffers::WIPOffset<Object<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Object>>(Schema::VT_ROOT_TABLE, root_table);
  }
  #[inline]
  pub fn add_services(&mut self, services: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Service<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Schema::VT_SERVICES, services);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SchemaBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SchemaBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Schema<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Schema::VT_OBJECTS,"objects");
    self.fbb_.required(o, Schema::VT_ENUMS,"enums");
    flatbuffers::WIPOffset::new(o.value())
  }
}

#[inline]
pub fn get_root_as_schema<'a>(buf: &'a [u8]) -> Schema<'a> {
  flatbuffers::get_root::<Schema<'a>>(buf)
}

#[inline]
pub fn get_size_prefixed_root_as_schema<'a>(buf: &'a [u8]) -> Schema<'a> {
  flatbuffers::get_size_prefixed_root::<Schema<'a>>(buf)
}

pub const SCHEMA_IDENTIFIER: &'static str = "BFBS";

#[inline]
pub fn schema_buffer_has_identifier(buf: &[u8]) -> bool {
  return flatbuffers::buffer_has_identifier(buf, SCHEMA_IDENTIFIER, false);
}

#[inline]
pub fn schema_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  return flatbuffers::buffer_has_identifier(buf, SCHEMA_IDENTIFIER, true);
}

pub const SCHEMA_EXTENSION: &'static str = "bfbs";

#[inline]
pub fn finish_schema_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Schema<'a>>) {
  fbb.finish(root, Some(SCHEMA_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_schema_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Schema<'a>>) {
  fbb.finish_size_prefixed(root, Some(SCHEMA_IDENTIFIER));
}
}  // pub mod reflection

