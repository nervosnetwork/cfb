use crate::exit_code::ExitCodeWithMessage;
use std::path::{Path, PathBuf};

#[derive(Debug)]
pub struct CliOptions {
    pub bfbs: PathBuf,
    pub output: PathBuf,
}

impl CliOptions {
    pub fn parse() -> Result<CliOptions, ExitCodeWithMessage> {
        Self::parse_from_matches(
            build_clap_app()
                .get_matches_safe()
                .map_err(|err| ExitCodeWithMessage::cli(err.message))?,
        )
    }

    pub fn parse_from_matches(
        matches: clap::ArgMatches,
    ) -> Result<CliOptions, ExitCodeWithMessage> {
        let bfbs = PathBuf::from(matches.value_of("bfbs").unwrap());
        if !bfbs.exists() {
            return Err(ExitCodeWithMessage::cli(
                "<bfbs> does not exist".to_string(),
            ));
        }

        let output = match matches
            .value_of("output")
            .map(PathBuf::from)
            .or_else(|| bfbs.parent().map(Path::to_path_buf))
            .filter(|path| ::std::fs::create_dir_all(path).is_ok())
        {
            Some(path) => path,
            None => {
                return Err(ExitCodeWithMessage::cli(
                    "<output> is not a valid output directory".to_string(),
                ));
            }
        };

        Ok(CliOptions { bfbs, output })
    }
}

fn build_clap_app() -> clap::App<'static, 'static> {
    let version = option_env!("CARGO_PKG_VERSION").unwrap_or("unknown");

    clap_app!(cfbc =>
        (version: version)
        (author: "Nervos Core Dev <dev@nervos.org>")
        (about: "CFB Code Generator")
        (@arg output: -o [dir] "Save all generated files in <dir>, instead of the directory containing <bfbs>.")
        (@arg bfbs: +required "Load schema from <bfbs> which is generated by `flatc -b --schema <fbs>`")
    )
}

#[cfg(test)]
mod test {
    use super::*;
    use tempfile::tempdir;

    fn parse(args: &[&str]) -> Result<CliOptions, ExitCodeWithMessage> {
        CliOptions::parse_from_matches(
            build_clap_app()
                .setting(clap::AppSettings::ColorNever)
                .get_matches_from_safe(args)
                .map_err(|err| ExitCodeWithMessage::cli(err.message))?,
        )
    }

    #[test]
    fn test_missing_required_argument() {
        let result = parse(&[""]);
        assert!(result.is_err());
        let err_message = result.unwrap_err().message().to_string();
        let expect_message = "error: The following required arguments were not provided";
        assert!(
            err_message.contains(expect_message),
            "expect \"{}\" in error: {}",
            expect_message,
            err_message
        );
    }

    #[test]
    fn test_file_not_found() {
        let result = parse(&["", "/dev/null/not/found"]);
        assert!(result.is_err());
        let err_message = result.unwrap_err().message().to_string();
        let expect_message = "<bfbs> does not exist";
        assert!(
            err_message.contains(expect_message),
            "expect \"{}\" in error: {}",
            expect_message,
            err_message
        );
    }

    #[test]
    fn test_output_not_valid_directory() {
        let dir = tempdir().expect("tempdir");
        let bfbs = dir.path().join("test.fbs");
        let output = dir.path().join("output");
        ::std::fs::File::create(&bfbs).expect("File::create");
        ::std::fs::File::create(&output).expect("File::create");

        let result = parse(&[
            "",
            "-o",
            output.to_string_lossy().as_ref(),
            bfbs.to_string_lossy().as_ref(),
        ]);
        assert!(result.is_err());
        let err_message = result.unwrap_err().message().to_string();
        let expect_message = "<output> is not a valid output directory";
        assert!(
            err_message.contains(expect_message),
            "expect \"{}\" in error: {}",
            expect_message,
            err_message
        );
    }

    #[test]
    fn test_parse_cli_options() {
        let dir = tempdir().expect("tempdir");
        let bfbs = dir.path().join("test.fbs");
        ::std::fs::File::create(&bfbs).expect("File::create");

        let result = parse(&["", bfbs.to_string_lossy().as_ref()]);
        assert!(result.is_ok(), "{}", result.unwrap_err().message());

        let cli_options = result.unwrap();
        assert_eq!(
            bfbs.canonicalize().ok(),
            cli_options.bfbs.canonicalize().ok()
        );
        assert_eq!(
            dir.path().canonicalize().ok(),
            cli_options.output.canonicalize().ok()
        );
    }

    #[test]
    fn test_parse_cli_options_with_specific_output() {
        let dir = tempdir().expect("tempdir");
        let bfbs = dir.path().join("test.fbs");
        let output = dir.path().join("output");
        ::std::fs::File::create(&bfbs).expect("File::create");

        let result = parse(&[
            "",
            "-o",
            output.to_string_lossy().as_ref(),
            bfbs.to_string_lossy().as_ref(),
        ]);
        assert!(result.is_ok(), "{}", result.unwrap_err().message());

        let cli_options = result.unwrap();
        assert_eq!(
            bfbs.canonicalize().ok(),
            cli_options.bfbs.canonicalize().ok()
        );
        assert_eq!(
            output.canonicalize().ok(),
            cli_options.output.canonicalize().ok()
        );
    }
}
