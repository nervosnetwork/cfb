// automatically generated by the FlatBuffers compiler, do not modify

use std::cmp::Ordering;
use std::mem;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[allow(non_camel_case_types)]
#[repr(i8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum Color {
    Red = 0,
    Green = 1,
    Blue = 2,
}

const ENUM_MIN_COLOR: i8 = 0;
const ENUM_MAX_COLOR: i8 = 2;

impl<'a> flatbuffers::Follow<'a> for Color {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::read_scalar_at::<Self>(buf, loc)
    }
}

impl flatbuffers::EndianScalar for Color {
    #[inline]
    fn to_little_endian(self) -> Self {
        let n = i8::to_le(self as i8);
        let p = &n as *const i8 as *const Color;
        unsafe { *p }
    }
    #[inline]
    fn from_little_endian(self) -> Self {
        let n = i8::from_le(self as i8);
        let p = &n as *const i8 as *const Color;
        unsafe { *p }
    }
}

impl flatbuffers::Push for Color {
    type Output = Color;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<Color>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_COLOR: [Color; 3] = [Color::Red, Color::Green, Color::Blue];

#[allow(non_camel_case_types)]
const ENUM_NAMES_COLOR: [&'static str; 3] = ["Red", "Green", "Blue"];

pub fn enum_name_color(e: Color) -> &'static str {
    let index = e as i8;
    ENUM_NAMES_COLOR[index as usize]
}

pub enum BagOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Bag<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Bag<'a> {
    type Inner = Bag<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Bag<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Bag { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BagArgs,
    ) -> flatbuffers::WIPOffset<Bag<'bldr>> {
        let mut builder = BagBuilder::new(_fbb);
        builder.add_color(args.color);
        builder.finish()
    }

    pub const VT_COLOR: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn color(&self) -> Color {
        self._tab
            .get::<Color>(Bag::VT_COLOR, Some(Color::Blue))
            .unwrap()
    }
}

pub struct BagArgs {
    pub color: Color,
}
impl<'a> Default for BagArgs {
    #[inline]
    fn default() -> Self {
        BagArgs { color: Color::Blue }
    }
}
pub struct BagBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BagBuilder<'a, 'b> {
    #[inline]
    pub fn add_color(&mut self, color: Color) {
        self.fbb_
            .push_slot::<Color>(Bag::VT_COLOR, color, Color::Blue);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BagBuilder<'a, 'b> {
        let start = _fbb.start_table();
        BagBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Bag<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}
