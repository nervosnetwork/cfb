// automatically generated by the FlatBuffers compiler, do not modify

use std::cmp::Ordering;
use std::mem;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[allow(non_camel_case_types)]
#[repr(i8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum Color {
    Red = 0,
    Green = 1,
    Blue = 2,
}

const ENUM_MIN_COLOR: i8 = 0;
const ENUM_MAX_COLOR: i8 = 2;

impl<'a> flatbuffers::Follow<'a> for Color {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::read_scalar_at::<Self>(buf, loc)
    }
}

impl flatbuffers::EndianScalar for Color {
    #[inline]
    fn to_little_endian(self) -> Self {
        let n = i8::to_le(self as i8);
        let p = &n as *const i8 as *const Color;
        unsafe { *p }
    }
    #[inline]
    fn from_little_endian(self) -> Self {
        let n = i8::from_le(self as i8);
        let p = &n as *const i8 as *const Color;
        unsafe { *p }
    }
}

impl flatbuffers::Push for Color {
    type Output = Color;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<Color>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_COLOR: [Color; 3] = [Color::Red, Color::Green, Color::Blue];

#[allow(non_camel_case_types)]
const ENUM_NAMES_COLOR: [&'static str; 3] = ["Red", "Green", "Blue"];

pub fn enum_name_color(e: Color) -> &'static str {
    let index = e as i8;
    ENUM_NAMES_COLOR[index as usize]
}

// struct Inner, aligned to 8
#[repr(C, align(8))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct Inner {
    x_: u64,
} // pub struct Inner
impl flatbuffers::SafeSliceAccess for Inner {}
impl<'a> flatbuffers::Follow<'a> for Inner {
    type Inner = &'a Inner;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        <&'a Inner>::follow(buf, loc)
    }
}
impl<'a> flatbuffers::Follow<'a> for &'a Inner {
    type Inner = &'a Inner;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::follow_cast_ref::<Inner>(buf, loc)
    }
}
impl<'b> flatbuffers::Push for Inner {
    type Output = Inner;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const Inner as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b Inner {
    type Output = Inner;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const Inner as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}

impl Inner {
    pub fn new<'a>(_x: u64) -> Self {
        Inner {
            x_: _x.to_little_endian(),
        }
    }
    pub fn x<'a>(&'a self) -> u64 {
        self.x_.from_little_endian()
    }
}

// struct Outter, aligned to 8
#[repr(C, align(8))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct Outter {
    x_: Inner,
    y_: Color,
    padding0__: u8,
    padding1__: u16,
    padding2__: u32,
    z_: u64,
} // pub struct Outter
impl flatbuffers::SafeSliceAccess for Outter {}
impl<'a> flatbuffers::Follow<'a> for Outter {
    type Inner = &'a Outter;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        <&'a Outter>::follow(buf, loc)
    }
}
impl<'a> flatbuffers::Follow<'a> for &'a Outter {
    type Inner = &'a Outter;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::follow_cast_ref::<Outter>(buf, loc)
    }
}
impl<'b> flatbuffers::Push for Outter {
    type Output = Outter;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const Outter as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b Outter {
    type Output = Outter;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const Outter as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}

impl Outter {
    pub fn new<'a>(_x: &'a Inner, _y: Color, _z: u64) -> Self {
        Outter {
            x_: *_x,
            y_: _y.to_little_endian(),
            z_: _z.to_little_endian(),

            padding0__: 0,
            padding1__: 0,
            padding2__: 0,
        }
    }
    pub fn x<'a>(&'a self) -> &'a Inner {
        &self.x_
    }
    pub fn y<'a>(&'a self) -> Color {
        self.y_.from_little_endian()
    }
    pub fn z<'a>(&'a self) -> u64 {
        self.z_.from_little_endian()
    }
}

pub enum WrapperOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Wrapper<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Wrapper<'a> {
    type Inner = Wrapper<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Wrapper<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Wrapper { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args WrapperArgs<'args>,
    ) -> flatbuffers::WIPOffset<Wrapper<'bldr>> {
        let mut builder = WrapperBuilder::new(_fbb);
        if let Some(x) = args.outter {
            builder.add_outter(x);
        }
        builder.finish()
    }

    pub const VT_OUTTER: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn outter(&self) -> Option<&'a Outter> {
        self._tab.get::<Outter>(Wrapper::VT_OUTTER, None)
    }
}

pub struct WrapperArgs<'a> {
    pub outter: Option<&'a Outter>,
}
impl<'a> Default for WrapperArgs<'a> {
    #[inline]
    fn default() -> Self {
        WrapperArgs { outter: None }
    }
}
pub struct WrapperBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WrapperBuilder<'a, 'b> {
    #[inline]
    pub fn add_outter(&mut self, outter: &'b Outter) {
        self.fbb_
            .push_slot_always::<&Outter>(Wrapper::VT_OUTTER, outter);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> WrapperBuilder<'a, 'b> {
        let start = _fbb.start_table();
        WrapperBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Wrapper<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}
